#! /usr/bin/env python
from __future__ import division

import rospy
from geometry_msgs.msg import Twist
from std_msgs.msg import Int32


class MotorCommand:
    def __init__(self):
        self.left = 0
        self.right = 0


class Controller:
    def __init__(self):
        self.maxMotorSpeed = 0
        self.wheelSeparation = 0
        self.maxVoltage = 0
        self.minVoltageValue = 0
        self.maxVoltageValue = 0

    def get_speeds(self, linear_speed, angular_speed):
        speeds = MotorCommand()

        # rate = linear_speed
        # diff = angular_speed * self.wheelSeparation
        # speeds.left = rate - diff
        # speeds.right = rate + diff

        speeds.left = (2 * linear_speed + self.wheelSeparation * angular_speed) / 2
        speeds.right = (2 * linear_speed - self.wheelSeparation * angular_speed) / 2

        speeds_adj = self.adjust_speeds(speeds)
        speeds_volt = self.speeds_to_voltage(speeds_adj)
        return speeds_volt

    def adjust_speeds(self, speeds):
        if max(speeds.left, speeds.right) > self.maxMotorSpeed:
            factor = self.maxMotorSpeed / max(speeds.left, speeds.right)
            speeds.left *= factor
            speeds.right *= factor
        if min(speeds.left, speeds.right) < -self.maxMotorSpeed:
            factor = -self.maxMotorSpeed / min(speeds.left, speeds.right)
            speeds.left *= factor
            speeds.right *= factor
        return speeds

    def clip(self, speed):
        sign = 1
        if speed < 0:
            sign = -1
        value = round(abs((speed / self.maxMotorSpeed) * self.maxVoltage))
        ret = value
        if self.minVoltageValue > value > 0:
            ret = self.minVoltageValue
        if value > self.maxVoltageValue:
            ret = self.maxVoltageValue
        return int(ret * sign)

    def speeds_to_voltage(self, speeds):
        speeds.left = self.clip(speeds.left)
        speeds.right = self.clip(speeds.right)
        return speeds

    def set_wheel_separation(self, separation):
        self.wheelSeparation = separation

    def set_max_motor_speed(self, limit):
        self.maxMotorSpeed = limit

    def set_max_voltage(self, limit):
        self.maxVoltage = limit

    def set_max_voltage_value(self, value):
        self.maxVoltageValue = value

    def set_min_voltage_value(self, value):
        self.minVoltageValue = value


class ControllerNode:

    def __init__(self):
        self.maxLinVel = 0
        self.maxAngVel = 0
        self.rate = 0
        self.timeout = 0
        self.name = ''
        self.needLogInfo = False

        self.controller = Controller()
        self.linearVelocity = 0.0
        self.angularVelocity = 0.0
        self.lastTwistTime = 0

        self.leftPub = rospy.Publisher('lwheel_desired_rate', Int32, queue_size=1)
        self.rightPub = rospy.Publisher('rwheel_desired_rate', Int32, queue_size=1)

    def main(self):
        rospy.init_node('diff_drive_controller')
        self.name = rospy.get_name()
        rospy.loginfo("{0} started".format(self.name))

        rospy.Subscriber("cmd_vel", Twist, self.twist_callback)

        self.maxLinVel = float(rospy.get_param('~max_lin_vel', 3.82))
        self.maxAngVel = float(rospy.get_param('~max_ang_vel', 3.82))
        self.rate = float(rospy.get_param('~controller_rate', 2.0))
        self.timeout = float(rospy.get_param('~controller_timeout', 2.0))
        self.needLogInfo = float(rospy.get_param('~controller_need_log_info', False))

        self.controller.set_wheel_separation(float(rospy.get_param('~wheel_separation', 0.450)))
        self.controller.set_max_motor_speed(float(rospy.get_param('~max_lin_vel', 3.82)))
        self.controller.set_max_voltage(int(rospy.get_param('~max_voltage', 255)))
        self.controller.set_max_voltage_value(int(rospy.get_param('~max_voltage_value', 255)))
        self.controller.set_min_voltage_value(int(rospy.get_param('~min_voltage_value', 0)))

        rate = rospy.Rate(self.rate)
        self.lastTwistTime = rospy.get_time()
        while not rospy.is_shutdown():
            self.publish()
            rate.sleep()

    def publish(self):
        if rospy.get_time() - self.lastTwistTime < self.timeout:
            speeds = self.controller.get_speeds(self.linearVelocity, self.angularVelocity)
            self.leftPub.publish(int(speeds.left))
            self.rightPub.publish(int(speeds.right))
            if self.needLogInfo:
                rospy.loginfo("[%s] voltage: left = %s; right = %s", self.name.upper(), int(speeds.left), int(speeds.right))
        else:
            self.leftPub.publish(0)
            self.rightPub.publish(0)
            if self.needLogInfo:
                rospy.loginfo("[%s] voltage: left = 0; right = 0", self.name.upper())

    def constrain(self, vel, low, high):
        if vel < low:
            vel = low
        elif vel > high:
            vel = high
        return vel

    def check_linear_limit_velocity(self, vel):
        return self.constrain(vel, -self.maxLinVel, self.maxLinVel)

    def check_angular_limit_velocity(self, vel):
        return self.constrain(vel, -self.maxAngVel, self.maxAngVel)

    def twist_callback(self, twist):

        self.linearVelocity = self.check_linear_limit_velocity(twist.linear.x)
        self.angularVelocity = self.check_angular_limit_velocity(twist.angular.z)
        if self.needLogInfo:
            rospy.loginfo("[%s] twist: lin = %s; ang = %s", self.name.upper(), twist.linear.x, twist.angular.z)
            rospy.loginfo("[%s] linear_speed_m/s=%s", self.name.upper(),  self.linearVelocity)
            rospy.loginfo("[%s] angular_speed_r/s=%s", self.name.upper(), self.angularVelocity)
        self.lastTwistTime = rospy.get_time()


if __name__ == '__main__':
    try:
        node = ControllerNode()
        node.main()
    except rospy.ROSInterruptException:
        pass
