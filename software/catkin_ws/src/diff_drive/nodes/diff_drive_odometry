#! /usr/bin/env python
from __future__ import division

import rospy
from geometry_msgs.msg import Quaternion
from nav_msgs.msg import Odometry
from std_msgs.msg import Int32
from geometry_msgs.msg import PoseWithCovarianceStamped
from tf.broadcaster import TransformBroadcaster
from tf.transformations import quaternion_from_euler, euler_from_quaternion
from math import pi, sin, cos


class Pose:

    def __init__(self):
        self.x = 0
        self.y = 0
        self.theta = 0
        self.xVel = 0
        self.yVel = 0
        self.thetaVel = 0

    def __str__(self):
        return str({'x': self.x, 'y': self.y, 'theta': self.theta,
                    'xVel': self.xVel, 'yVel': self.yVel, 'thetaVel': self.thetaVel})


class Encoder:
    """Monitors a single wheel encoder and accumulates delta ticks
    since the last time they were requested.
    """

    def __init__(self):
        self.delta = 0
        self.isReversed = False

    def set_delta(self, delta):
        self.delta = delta

    def set_reversed(self, is_reversed):
        self.isReversed = is_reversed

    def get_delta(self):
        if self.isReversed:
            return -self.delta
        else:
            return self.delta


class OdometrySet:
    """Keeps track of the current position and velocity of a
    robot using differential drive.
    """

    def __init__(self):
        self.wheelSeparation = 0
        self.ticksPerMeter = 0
        self.name = ''
        self.need_log_info = False

        self.leftEncoder = Encoder()
        self.rightEncoder = Encoder()
        self.pose = Pose()
        self.lastTime = 0

    def set_wheel_separation(self, separation):
        self.wheelSeparation = separation

    def set_ticks_per_meter(self, ticks):
        self.ticksPerMeter = ticks

    def set_time(self, new_time):
        self.lastTime = new_time

    def update_left_wheel(self, new_count):
        self.leftEncoder.set_delta(new_count)

    def update_right_wheel(self, new_count):
        self.rightEncoder.set_delta(new_count)

    def update_pose(self, new_time):
        """Updates the pose based on the accumulated encoder ticks
        of the two wheels. See https://chess.eecs.berkeley.edu/eecs149/documentation/differentialDrive.pdf
        for details.
        """
        left_tick_delta = self.leftEncoder.get_delta()
        left_travel = left_tick_delta / self.ticksPerMeter
        right_travel = self.rightEncoder.get_delta() / self.ticksPerMeter
        delta_time = new_time - self.lastTime

        delta_travel = (right_travel + left_travel) / 2
        delta_theta = (right_travel - left_travel) / self.wheelSeparation

        if right_travel == left_travel:
            delta_x = left_travel * cos(self.pose.theta)
            delta_y = left_travel * sin(self.pose.theta)
        else:
            radius = delta_travel / delta_theta

            # Find the instantaneous center of curvature (ICC).
            icc_x = self.pose.x - radius * sin(self.pose.theta)
            icc_y = self.pose.y + radius * cos(self.pose.theta)

            delta_x = cos(delta_theta) * (self.pose.x - icc_x) \
                - sin(delta_theta) * (self.pose.y - icc_y) \
                + icc_x - self.pose.x

            delta_y = sin(delta_theta) * (self.pose.x - icc_x) \
                + cos(delta_theta) * (self.pose.y - icc_y) \
                + icc_y - self.pose.y

        self.pose.x += delta_x
        self.pose.y += delta_y
        self.pose.theta = (self.pose.theta + delta_theta) % (2 * pi)
        self.pose.xVel = delta_travel / delta_time if delta_time > 0 else 0.
        self.pose.yVel = 0
        self.pose.thetaVel = delta_theta / delta_time if delta_time > 0 else 0.

        self.lastTime = new_time
        if self.need_log_info:
            rospy.loginfo("[%s] delta_tick = %s; delta_time = %s", self.name.upper(), left_tick_delta, delta_time)
            rospy.loginfo("[%s] odom: lin = %s; ang = %s", self.name.upper(), self.pose.xVel, self.pose.thetaVel)

    def get_pose(self):
        return self.pose

    def set_pose(self, new_pose):
        self.pose = new_pose

    def set_name(self, name):
        self.name = name

    def set_need_lo_info(self, need):
        self.need_log_info = need


class OdometryNode:
    def __init__(self):
        self.rate = 0.0
        self.baseFrameID = ''
        self.odomFrameID = ''
        self.name = ''
        self.need_log_info = False

        self.odometry = OdometrySet()

        self.odomPub = rospy.Publisher('odom', Odometry, queue_size=10)
        self.tfPub = TransformBroadcaster()

    def main(self):
        rospy.init_node('diff_drive_odometry')
        self.name = rospy.get_name()
        rospy.loginfo("{0} started".format(self.name))

        rospy.Subscriber("lwheel_ticks", Int32, self.left_callback)
        rospy.Subscriber("rwheel_ticks", Int32, self.right_callback)
        rospy.Subscriber("initialpose", PoseWithCovarianceStamped, self.on_initial_pose)

        self.rate = rospy.Rate(float(rospy.get_param('~odom_rate', 5.0)))
        self.baseFrameID = rospy.get_param('~base_frame_id', 'base_link')
        self.odomFrameID = rospy.get_param('~odom_frame_id', 'odom')
        self.need_log_info = float(rospy.get_param('~odom_need_log_info', False))

        self.odometry.set_wheel_separation(float(rospy.get_param('~wheel_separation', 0.450)))
        self.odometry.set_ticks_per_meter(float(rospy.get_param('~ticks_per_meter', 362)))
        self.odometry.set_name(self.name)
        self.odometry.set_need_lo_info(self.need_log_info)
        self.odometry.set_time(rospy.get_time())

        while not rospy.is_shutdown():
            self.publish()
            self.rate.sleep()

    def publish(self):
        self.odometry.update_pose(rospy.get_time())
        now = rospy.get_rostime()
        pose = self.odometry.get_pose()

        q = quaternion_from_euler(0, 0, pose.theta)
        self.tfPub.sendTransform(
            (pose.x, pose.y, 0),
            (q[0], q[1], q[2], q[3]),
            now,
            self.baseFrameID,
            self.odomFrameID
        )

        odom = Odometry()
        odom.header.stamp = now
        odom.header.frame_id = self.odomFrameID
        odom.child_frame_id = self.baseFrameID
        odom.pose.pose.position.x = pose.x
        odom.pose.pose.position.y = pose.y
        odom.pose.pose.orientation.x = q[0]
        odom.pose.pose.orientation.y = q[1]
        odom.pose.pose.orientation.z = q[2]
        odom.pose.pose.orientation.w = q[3]
        odom.twist.twist.linear.x = pose.xVel
        odom.twist.twist.angular.z = pose.thetaVel
        self.odomPub.publish(odom)

    def on_initial_pose(self, msg):
        q = [msg.pose.pose.orientation.x,
             msg.pose.pose.orientation.x,
             msg.pose.pose.orientation.x,
             msg.pose.pose.orientation.w]
        roll, pitch, yaw = euler_from_quaternion(q)

        pose = Pose()
        pose.x = msg.pose.pose.position.x
        pose.y = msg.pose.pose.position.y
        pose.theta = yaw

        rospy.loginfo('Setting initial pose to %s', pose)
        self.odometry.set_pose(pose)

    def left_callback(self, msg):
        self.odometry.update_left_wheel(msg.data)

    def right_callback(self, msg):
        self.odometry.update_right_wheel(msg.data)


if __name__ == '__main__':
    try:
        node = OdometryNode()
        node.main()
    except rospy.ROSInterruptException:
        pass
