#! /usr/bin/env python
from __future__ import division

import rospy
from math import pi, asin
from geometry_msgs.msg import Twist, Pose
from nav_msgs.msg import Odometry
from std_msgs.msg import Int32


class MotorTicks:

    def __init__(self):
        self.left = 0
        self.right = 0

class Robot:
    """Implements a mock robot that dutifully executes its wheel
    speed commands exactly.
    """

    def __init__(self):
        self.leftSpeed = 0
        self.newLeftSpeed = 0
        self.rightSpeed = 0
        self.newRightSpeed = 0
        self.leftTicks = 0
        self.rightTicks = 0
        self.minTicks = -32768
        self.maxTicks = 32767

    def setSpeeds(self, left, right):
        self.newLeftSpeed = left
        self.newRightSpeed = right

    def updateRobot(self, dTime):
        self.leftTicks = self.addTicks(self.leftTicks, self.leftSpeed*dTime)
        self.rightTicks = self.addTicks(self.rightTicks, self.rightSpeed*dTime)
        self.leftSpeed = self.newLeftSpeed
        self.rightSpeed = self.newRightSpeed

    def getTicks(self):
        ticks = MotorTicks()
        ticks.left = self.leftTicks
        ticks.right = self.rightTicks
        return ticks

    def addTicks(self, ticks, deltaTicks):
        ticks += deltaTicks
        if ticks > self.maxTicks:
            return int(ticks - self.maxTicks + self.minTicks)
        elif ticks < self.minTicks:
            return int(ticks - self.minTicks + self.maxTicks)
        else:
            return int(ticks)


class RobotNode:

    def __init__(self):
        self.robot = Robot()
        self.leftSpeed = 0
        self.rightSpeed = 0

    def main(self):
        rospy.init_node('diff_drive_robot')
        self.leftPub = rospy.Publisher('lwheel_ticks', Int32, queue_size=10)
        self.rightPub = rospy.Publisher('rwheel_ticks', Int32, queue_size=10)

        self.nodeName = rospy.get_name()
        rospy.loginfo("{0} started".format(self.nodeName))

        rospy.Subscriber('lwheel_desired_rate', Int32, self.leftCallback)
        rospy.Subscriber('rwheel_desired_rate', Int32, self.rightCallback)

        self.rate = rospy.get_param('~rate', 10.0)
        self.timeout = rospy.get_param('~timeout', 0.5)

        rate = rospy.Rate(self.rate)
        self.lastTime = rospy.get_time()
        while not rospy.is_shutdown():
            self.publish()
            rate.sleep()

    def publish(self):
        newTime = rospy.get_time()
        diffTime = newTime - self.lastTime
        self.lastTime = newTime

        if diffTime > self.timeout:
            self.robot.setSpeeds(0, 0)
    
        try:
            self.robot.updateRobot(diffTime)
        except:
            rospy.logerror("Got exception updating robot")
        ticks = self.robot.getTicks()
        self.leftPub.publish(ticks.left)
        self.rightPub.publish(ticks.right)

    def leftCallback(self, leftSpeed):
        self.leftSpeed = leftSpeed.data
        self.robot.setSpeeds(self.leftSpeed, self.rightSpeed)

    def rightCallback(self, rightSpeed):
        self.rightSpeed = rightSpeed.data
        self.robot.setSpeeds(self.leftSpeed, self.rightSpeed)


if __name__ == '__main__':
    try:
        node = RobotNode()
        node.main()
    except rospy.ROSInterruptException:
        pass
